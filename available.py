# -*- coding: utf-8 -*-
"""Feature1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zj0A8TmMZUFi5s87JSlgy1U2xW5EeJ78
"""

!pip install ortools

import pandas as pd
from itertools import product
from sklearn.ensemble import RandomForestRegressor
from ortools.linear_solver import pywraplp

# Sample data
data = {'Doctor': ['Doctor_A', 'Doctor_B', 'Doctor_C'],
        'Availability': [2, 3, 2]}
doctors_df = pd.DataFrame(data)

# Assuming you have historical data with features like patient preferences, urgency, etc.
# Here, I'll create a dummy dataset for illustration purposes
appointments_data = {'Doctor': ['Doctor_A', 'Doctor_A', 'Doctor_B', 'Doctor_C', 'Doctor_C'],
                     'Patient': ['Patient_1', 'Patient_2', 'Patient_2', 'Patient_3', 'Patient_1'],
                     'Urgency': [1, 2, 2, 3, 1]}
appointments_df = pd.DataFrame(appointments_data)

# Merge dataframes
merged_df = pd.merge(appointments_df, doctors_df, on='Doctor')

# Feature engineering (dummy encoding for simplicity)
X = pd.get_dummies(merged_df[['Doctor', 'Urgency']])
y = merged_df['Availability']

# Train a simple RandomForestRegressor (you might need a more sophisticated model in practice)
model = RandomForestRegressor()
model.fit(X, y)

# Predict availability for all combinations of doctors and patients
all_combinations = pd.DataFrame(list(product(doctors_df['Doctor'], appointments_df['Patient'])), columns=['Doctor', 'Patient'])
X_all_combinations = pd.get_dummies(all_combinations[['Doctor', 'Patient']])

# Align feature names
missing_features = set(X.columns) - set(X_all_combinations.columns)
for feature in missing_features:
    X_all_combinations[feature] = 0

# Ensure the order of columns is the same
X_all_combinations = X_all_combinations[X.columns]

all_combinations['Predicted_Availability'] = model.predict(X_all_combinations)

# Integer programming to optimize scheduling
solver = pywraplp.Solver.CreateSolver('SCIP')
schedule_vars = {(doc, pat): solver.IntVar(0, 1, f'Schedule_{doc}_{pat}') for doc, pat in product(doctors_df['Doctor'], appointments_df['Patient'])}

# Objective function: minimize the sum of predicted availabilities for scheduled appointments
solver.Minimize(solver.Sum(all_combinations.at[i, 'Predicted_Availability'] * schedule_vars[all_combinations.at[i, 'Doctor'], all_combinations.at[i, 'Patient']] for i in range(len(all_combinations))))

# Constraints: each patient can only be assigned to one doctor
for pat in appointments_df['Patient'].unique():
    solver.Add(solver.Sum(schedule_vars[doc, pat] for doc in doctors_df['Doctor']) == 1)

# Constraints: each doctor can only take a certain number of appointments
for doc in doctors_df['Doctor']:
    solver.Add(solver.Sum(schedule_vars[doc, pat] for pat in appointments_df['Patient']) <= doctors_df.loc[doctors_df['Doctor'] == doc, 'Availability'].values[0])

# Solve the problem
solver.Solve()

# Print the schedule
for doc, pat in schedule_vars:
    if schedule_vars[doc, pat].solution_value() == 1:
        print(f"{pat} is scheduled with {doc}")